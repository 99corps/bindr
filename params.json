{"name":"Bindr","tagline":"A small JavaScript dependency injection framework.","body":"bindr\r\n=====\r\nDependency injection is a software pattern that helps increase the testability of a given class by removing hard coded references to its dependencies.\r\n\r\nIn other words, take the following code...\r\n\r\n```js\r\nfunction Car(make, model, color) {\r\n    this.make = make;\r\n    this.model = model;\r\n    this.color = color;\r\n\r\n    this.service = new Service();\r\n}\r\n```\r\n\r\nIn the preceding code, `Car` is now dependent upon `Service`. This makes it more difficult to unit test the `Car` in complete isolation. There's no way to create an\r\ninstance of a `Car` without in turn creating an instance of a `Service`.\r\n\r\nDependency injection allows for a small bit of configuration that says, 'When a class needs a dependency named x, create an instance of y'.\r\n\r\nSo, you can now have code that would look like...\r\n\r\n```js\r\nfunction Car(make, model, color, service) {\r\n    this.make = make;\r\n    this.model = model;\r\n    this.color = color;\r\n    this.service = service;\r\n\r\n    bindr(this, arguments);\r\n}\r\n\r\nbindr.bind('service', Service);\r\n```\r\n\r\nYou now accept your service as an argument in the constructor. \r\n\r\n`bindr` comes in and allows you to switch a dependencies constructor out. In production code, the `Car` might be dependent upon `Service`, but when writing unit tests,\r\n`bindr` allows you to swap that dependency out for a `FakeService`.\r\n\r\n```js\r\nvar Car = require('Car'),\r\n    bindr = require('bindr');\r\n\r\nfunction FakeService() {}\r\n\r\nbindr.bind('service', FakeService);\r\n\r\ndescribe('when a car is created', function() {\r\n    it('should be awesome', function() {\r\n        var car = new Car();\r\n\r\n        expect(car.service instanceof FakeService).to.be.ok();\r\n    });\r\n});\r\n```\r\n\r\nIn the unit tests, you simply bind service to `FakeService` instead of `Service` and the dependency will automatically get passed in.\r\n\r\n### AMD\r\nAnother nice feature of `bindr` is its use in AMD projects with Require.js.\r\n\r\nIn a typical AMD module, you'd have code such as the following...\r\n\r\n```js\r\n// car.js\r\ndefine(['service'], function(Service) {\r\n    function Car() {\r\n        this.make = make;\r\n        this.model = model;\r\n        this.color = color;\r\n        this.service = new Service();\r\n    }\r\n\r\n    return Car;\r\n});\r\n```\r\n\r\nYou can see that when you require `car`, you automtically end up requiring `service` as well. `bindr` allows you to remove that dependency from the `car` module and swap \r\nout what service the car uses.\r\n\r\n```js\r\n// main.js\r\nrequire.config({\r\n    paths: {\r\n        'bindr': '../../../dist/bindr'\r\n    }\r\n});\r\n\r\nrequire(['bindr', 'car', 'service'], function(bindr, Car, Service) {\r\n    bindr.bind('service', Service);\r\n\r\n    var ford = new Car('Ford', 'Fusion', 'Maroon');\r\n\r\n    document.getElementById('car').innerHTML = JSON.stringify(ford, null, 4);\r\n});\r\n\r\n// car.js\r\ndefine(['bindr'], function (bindr) {\r\n    function Car(make, model, color, service) {\r\n        this.make = make;\r\n        this.model = model;\r\n        this.color = color;\r\n        this.service = service;\r\n        \r\n        bindr(this, arguments);\r\n    }\r\n\r\n    return Car;\r\n});\r\n```\r\n\r\nThis way you can easily swap out the `service` dependency of the `car`.\r\n\r\n----------------------------------------------------\r\n\r\nAny feedback would be appreciated!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}